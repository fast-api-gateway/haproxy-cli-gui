#!/bin/bash
# Module: config-writer.sh
# Purpose: Write HAProxy configuration from memory structures to file
# CRITICAL: This module ENFORCES mandatory backup before ANY write operation

# Write complete configuration to file
# Args: $1 = target config file path
#       $2 = reason for change (optional)
# Returns: 0 on success, 1 on failure
# IMPORTANT: Creates mandatory backup before write
write_config_file() {
    local target_file="$1"
    local reason="${2:-Configuration update}"
    local temp_file="${target_file}.tmp.$$"
    local backup_file

    log_info "========================================"
    log_info "CONFIGURATION WRITE OPERATION STARTING"
    log_info "========================================"

    # Validate input
    if [[ -z "$target_file" ]]; then
        log_error "write_config_file: No target file specified"
        return 1
    fi

    if ! is_config_loaded; then
        log_error "write_config_file: No configuration loaded in memory"
        return 1
    fi

    # MANDATORY BACKUP - THIS IS CRITICAL
    if [[ -f "$target_file" ]]; then
        log_info "**MANDATORY BACKUP**: Creating full backup before write..."

        backup_file=$(mandatory_backup_before_write "$target_file" "$reason")
        local backup_result=$?

        if [[ $backup_result -ne 0 ]]; then
            log_error "**CRITICAL FAILURE**: Mandatory backup failed!"
            log_error "Write operation ABORTED for safety"
            log_error "Configuration will NOT be modified"
            return 1
        fi

        show_success "Mandatory backup created: $(basename "$backup_file")"
    else
        log_info "New configuration file (no backup needed)"
    fi

    # Serialize configuration to temp file
    log_info "Writing configuration to temp file..."
    {
        write_config_header
        write_all_sections
    } > "$temp_file" 2>/dev/null

    if [[ $? -ne 0 ]]; then
        log_error "Failed to write temp configuration file"
        rm -f "$temp_file" 2>/dev/null
        return 1
    fi

    # Verify temp file was created and has content
    if [[ ! -f "$temp_file" ]] || [[ ! -s "$temp_file" ]]; then
        log_error "Temp file is missing or empty"
        rm -f "$temp_file" 2>/dev/null
        return 1
    fi

    # Validate temp configuration (if validator is available)
    if declare -f validate_config_file &>/dev/null; then
        log_info "Validating configuration before applying..."
        if ! validate_config_file "$temp_file"; then
            log_error "Configuration validation FAILED"
            log_error "Write operation ABORTED"
            rm -f "$temp_file" 2>/dev/null

            # Offer to restore backup if validation fails
            if [[ -n "$backup_file" ]]; then
                log_warn "Backup is safe at: $backup_file"
                log_warn "You can restore it if needed"
            fi
            return 1
        fi
        show_success "Configuration validation passed"
    fi

    # Preserve original file permissions if it exists
    if [[ -f "$target_file" ]]; then
        chmod --reference="$target_file" "$temp_file" 2>/dev/null || \
        chmod 644 "$temp_file" 2>/dev/null
    else
        chmod 644 "$temp_file" 2>/dev/null
    fi

    # Atomic move to target file
    log_info "Applying configuration (atomic move)..."
    if ! mv -f "$temp_file" "$target_file" 2>/dev/null; then
        log_error "Failed to move temp file to target: $target_file"
        rm -f "$temp_file" 2>/dev/null

        # Offer to restore backup
        if [[ -n "$backup_file" ]]; then
            log_error "Configuration may be corrupted!"
            log_warn "Backup is safe at: $backup_file"
            log_warn "Run: restore_backup \"$backup_file\" \"$target_file\""
        fi
        return 1
    fi

    # Update config file hash
    CONFIG_FILE_HASH=$(get_file_hash "$target_file")

    log_info "========================================"
    log_info "CONFIGURATION WRITE COMPLETED"
    log_info "========================================"
    show_success "Configuration written successfully to: $target_file"

    if [[ -n "$backup_file" ]]; then
        show_info "Backup available at: $(basename "$backup_file")"
    fi

    return 0
}

# Write configuration file header
write_config_header() {
    cat <<'EOF'
#---------------------------------------------------------------------
# HAProxy Configuration
# Generated by HAProxy CLI GUI
# DO NOT EDIT MANUALLY WHILE GUI IS RUNNING
#---------------------------------------------------------------------

EOF
}

# Write all sections in proper order
write_all_sections() {
    # Write sections in order: global, defaults, frontend, backend, listen
    for section in "${SECTION_LIST[@]}"; do
        write_section "$section"
    done
}

# Write a single section
# Args: $1 = section name
write_section() {
    local section="$1"

    if ! section_exists "$section"; then
        log_warn "write_section: Section does not exist: $section"
        return 1
    fi

    # Write section header
    if [[ "$section" == "global" ]] || [[ "$section" == "defaults" ]]; then
        echo "$section"
    elif [[ "$section" =~ ^([^:]+):(.+)$ ]]; then
        local section_type="${BASH_REMATCH[1]}"
        local section_name="${BASH_REMATCH[2]}"
        echo "$section_type $section_name"
    else
        echo "$section"
    fi

    # Write single-value directives (sorted for consistency)
    for key in $(printf '%s\n' "${!CONFIG[@]}" | grep "^${section}:" | sort); do
        if [[ "$key" =~ ^${section}:(.+)$ ]]; then
            local directive="${BASH_REMATCH[1]}"
            local value="${CONFIG[$key]}"
            local comment="${CONFIG_COMMENTS[$key]:-}"

            if [[ -n "$comment" ]]; then
                printf "    %-30s %s\n" "$directive $value" "$comment"
            else
                printf "    %s %s\n" "$directive" "$value"
            fi
        fi
    done

    # Write array directives (in order)
    local last_directive=""
    for key in $(printf '%s\n' "${!CONFIG_ARRAYS[@]}" | grep "^${section}:" | sort); do
        if [[ "$key" =~ ^${section}:([^:]+):([0-9]+)$ ]]; then
            local directive="${BASH_REMATCH[1]}"
            local value="${CONFIG_ARRAYS[$key]}"

            # Add blank line between different directive types for readability
            if [[ -n "$last_directive" ]] && [[ "$last_directive" != "$directive" ]]; then
                echo ""
            fi

            printf "    %s %s\n" "$directive" "$value"
            last_directive="$directive"
        fi
    done

    echo ""  # Blank line after section
}

# Add a new section to configuration
# Args: $1 = section type (frontend, backend, listen)
#       $2 = section name
# Returns: 0 on success, 1 on failure
add_section() {
    local section_type="$1"
    local section_name="$2"
    local section

    # Validate input
    if [[ -z "$section_type" ]] || [[ -z "$section_name" ]]; then
        log_error "add_section: Missing section type or name"
        return 1
    fi

    # Validate section type
    if ! array_contains "$section_type" "frontend" "backend" "listen"; then
        log_error "add_section: Invalid section type: $section_type"
        return 1
    fi

    # Validate section name
    if ! is_valid_section_name "$section_name"; then
        log_error "add_section: Invalid section name: $section_name"
        return 1
    fi

    section="${section_type}:${section_name}"

    # Check if section already exists
    if section_exists "$section"; then
        log_error "add_section: Section already exists: $section"
        return 1
    fi

    # Add to section list
    SECTION_LIST+=("$section")
    CONFIG_ORDER["$section"]=${#SECTION_LIST[@]}

    log_info "Added section: $section"
    return 0
}

# Update/add a directive in a section
# Args: $1 = section
#       $2 = directive name
#       $3 = directive value
# Returns: 0 on success, 1 on failure
set_directive() {
    local section="$1"
    local directive="$2"
    local value="$3"
    local key="${section}:${directive}"

    # Validate input
    if [[ -z "$section" ]] || [[ -z "$directive" ]]; then
        log_error "set_directive: Missing section or directive"
        return 1
    fi

    # Check if section exists
    if ! section_exists "$section"; then
        log_error "set_directive: Section does not exist: $section"
        return 1
    fi

    # Set directive value
    CONFIG["$key"]="$value"

    log_debug "Set directive: $key = $value"
    return 0
}

# Delete a directive from a section
# Args: $1 = section
#       $2 = directive name
# Returns: 0 on success, 1 on failure
delete_directive() {
    local section="$1"
    local directive="$2"
    local key="${section}:${directive}"

    # Validate input
    if [[ -z "$section" ]] || [[ -z "$directive" ]]; then
        log_error "delete_directive: Missing section or directive"
        return 1
    fi

    # Delete directive
    unset CONFIG["$key"]
    unset CONFIG_COMMENTS["$key"]

    log_debug "Deleted directive: $key"
    return 0
}

# Add an array directive (server, bind, acl, etc.)
# Args: $1 = section
#       $2 = directive name
#       $3 = directive value
# Returns: 0 on success, 1 on failure
add_array_directive_value() {
    local section="$1"
    local directive="$2"
    local value="$3"
    local key="${section}:${directive}"
    local index=0

    # Validate input
    if [[ -z "$section" ]] || [[ -z "$directive" ]] || [[ -z "$value" ]]; then
        log_error "add_array_directive_value: Missing required arguments"
        return 1
    fi

    # Check if section exists
    if ! section_exists "$section"; then
        log_error "add_array_directive_value: Section does not exist: $section"
        return 1
    fi

    # Find next available index
    while [[ -n "${CONFIG_ARRAYS[${key}:${index}]}" ]]; do
        ((index++))
    done

    CONFIG_ARRAYS["${key}:${index}"]="$value"

    log_debug "Added array directive: ${key}:${index} = $value"
    return 0
}

# Update an array directive at specific index
# Args: $1 = section
#       $2 = directive name
#       $3 = index
#       $4 = new value
# Returns: 0 on success, 1 on failure
update_array_directive_value() {
    local section="$1"
    local directive="$2"
    local index="$3"
    local value="$4"
    local key="${section}:${directive}:${index}"

    # Validate input
    if [[ -z "$section" ]] || [[ -z "$directive" ]] || [[ -z "$index" ]]; then
        log_error "update_array_directive_value: Missing required arguments"
        return 1
    fi

    # Check if exists
    if [[ -z "${CONFIG_ARRAYS[$key]}" ]]; then
        log_error "update_array_directive_value: Array directive not found: $key"
        return 1
    fi

    CONFIG_ARRAYS["$key"]="$value"

    log_debug "Updated array directive: $key = $value"
    return 0
}

# Delete an array directive at specific index
# Args: $1 = section
#       $2 = directive name
#       $3 = index
# Returns: 0 on success, 1 on failure
delete_array_directive_value() {
    local section="$1"
    local directive="$2"
    local index="$3"
    local key="${section}:${directive}:${index}"

    # Validate input
    if [[ -z "$section" ]] || [[ -z "$directive" ]] || [[ -z "$index" ]]; then
        log_error "delete_array_directive_value: Missing required arguments"
        return 1
    fi

    unset CONFIG_ARRAYS["$key"]

    log_debug "Deleted array directive: $key"

    # Reindex remaining items to maintain order
    reindex_array_directive "$section" "$directive"

    return 0
}

# Reindex array directive values after deletion
# Args: $1 = section
#       $2 = directive name
reindex_array_directive() {
    local section="$1"
    local directive="$2"
    local key_prefix="${section}:${directive}"
    local -a values=()
    local index

    # Collect all existing values
    index=0
    while true; do
        local key="${key_prefix}:${index}"
        if [[ -n "${CONFIG_ARRAYS[$key]}" ]]; then
            values+=("${CONFIG_ARRAYS[$key]}")
        fi
        ((index++))
        # Stop when we've checked enough indices
        if [[ $index -gt 1000 ]]; then
            break
        fi
    done

    # Clear all existing entries
    for key in "${!CONFIG_ARRAYS[@]}"; do
        if [[ "$key" =~ ^${key_prefix}:[0-9]+$ ]]; then
            unset CONFIG_ARRAYS["$key"]
        fi
    done

    # Rewrite with sequential indices
    index=0
    for value in "${values[@]}"; do
        CONFIG_ARRAYS["${key_prefix}:${index}"]="$value"
        ((index++))
    done
}

# Delete an entire section
# Args: $1 = section
# Returns: 0 on success, 1 on failure
delete_section() {
    local section="$1"

    if [[ -z "$section" ]]; then
        log_error "delete_section: No section specified"
        return 1
    fi

    if ! section_exists "$section"; then
        log_error "delete_section: Section does not exist: $section"
        return 1
    fi

    # Delete all directives in section
    for key in "${!CONFIG[@]}"; do
        if [[ "$key" =~ ^${section}: ]]; then
            unset CONFIG["$key"]
            unset CONFIG_COMMENTS["$key"]
        fi
    done

    # Delete all array directives in section
    for key in "${!CONFIG_ARRAYS[@]}"; do
        if [[ "$key" =~ ^${section}: ]]; then
            unset CONFIG_ARRAYS["$key"]
        fi
    done

    # Remove from section list
    local new_list=()
    for s in "${SECTION_LIST[@]}"; do
        if [[ "$s" != "$section" ]]; then
            new_list+=("$s")
        fi
    done
    SECTION_LIST=("${new_list[@]}")

    # Remove from order
    unset CONFIG_ORDER["$section"]

    log_info "Deleted section: $section"
    return 0
}

# Clone a section with a new name
# Args: $1 = source section
#       $2 = new section name
# Returns: 0 on success, 1 on failure
clone_section() {
    local source_section="$1"
    local new_name="$2"
    local section_type
    local new_section

    if [[ -z "$source_section" ]] || [[ -z "$new_name" ]]; then
        log_error "clone_section: Missing arguments"
        return 1
    fi

    if ! section_exists "$source_section"; then
        log_error "clone_section: Source section does not exist: $source_section"
        return 1
    fi

    # Extract section type
    if [[ "$source_section" =~ ^([^:]+):(.+)$ ]]; then
        section_type="${BASH_REMATCH[1]}"
    else
        log_error "clone_section: Cannot clone global or defaults sections"
        return 1
    fi

    new_section="${section_type}:${new_name}"

    # Check if new section already exists
    if section_exists "$new_section"; then
        log_error "clone_section: Target section already exists: $new_section"
        return 1
    fi

    # Add new section
    add_section "$section_type" "$new_name" || return 1

    # Copy all directives
    for key in "${!CONFIG[@]}"; do
        if [[ "$key" =~ ^${source_section}:(.+)$ ]]; then
            local directive="${BASH_REMATCH[1]}"
            CONFIG["${new_section}:${directive}"]="${CONFIG[$key]}"
            if [[ -n "${CONFIG_COMMENTS[$key]:-}" ]]; then
                CONFIG_COMMENTS["${new_section}:${directive}"]="${CONFIG_COMMENTS[$key]}"
            fi
        fi
    done

    # Copy all array directives
    for key in "${!CONFIG_ARRAYS[@]}"; do
        if [[ "$key" =~ ^${source_section}:(.+)$ ]]; then
            local remainder="${BASH_REMATCH[1]}"
            CONFIG_ARRAYS["${new_section}:${remainder}"]="${CONFIG_ARRAYS[$key]}"
        fi
    done

    log_info "Cloned section: $source_section -> $new_section"
    return 0
}

# Export functions
export -f write_config_file write_config_header write_all_sections write_section
export -f add_section set_directive delete_directive
export -f add_array_directive_value update_array_directive_value delete_array_directive_value
export -f reindex_array_directive delete_section clone_section

log_debug "Configuration writer module loaded (with MANDATORY backup enforcement)"
